\chapter{Implementación}
En todo proyecto existen una serie de decisiones que marcan el avance del proyecto. En este capítulo se describirán, detalladamente, las justificaciones de cada decisión que se tome durante el desarrollo del mismo. Otorgando tanto al lector como a cualquier desarrollador que busque continuar este proyecto, un entendimiento de porqué se han tomado dichas decisiones.

\section{Lenguaje del proyecto}
Para el desarrollo del proyecto, ya sea una plataforma web o una biblioteca, es necesario definir un lenguaje. Aunque no conste como requisito imprescindible, debe adecuarse a mi habilidad de desarrollo en el lenguaje, con el objetivo de una robustez y eficiencia en la codificación de la solución al problema planteado. 

Se ha elegido \Gls{python} como lenguaje de desarrollo, siendo el lenguaje con el que más experiencia cuento. Además de conocer frameworks útiles en este lenguaje que pueden ayudar al al desarrollo del proyecto.

\section{Gestor de dependencias}
En el desarrollo de software, un gestor de \glspl{dependencia} es fundamental para administrar las bibliotecas de las que hace uso el proyecto. Si trabaja una sola persona, puede que no sea tan complicado llevar una coherencia en las versiones de las \glspl{dependencia}. Pero si se da el caso que el proyecto empieza a crecer, aumentando tanto el número de \glspl{dependencia} como el de trabajadores, cada vez se hará más complicado. Por ello es muy importante llevar un control de \glspl{dependencia} desde el inicio del proyecto.

Existen multitud de gestores de \glspl{dependencia} orientados al uso de \Gls{python} como para hablar de todos, para que el proyecto sea lo más sencillo posible, teniendo en cuenta la necesidad de controlar las \glspl{dependencia} que vayan añadiéndose a lo largo del desarrollo se usará \Gls{poetry}, aunque \Gls{pip} viene instalado por defecto en todas las versiones de \Gls{python}. 

Para instalar \gls{poetry}, es necesario descargarlo desde su propio repositorio, ya que no se encuentra en los repositorios incluidos con Linux. Y se añade la aplicación al \gls{path} para poder encontrar la utilidad de manera sencilla.
\begin{lstlisting}[style=consola]
	curl -sSL https://install.python-poetry.org | python3 -
	$HOME/.local/bin
\end{lstlisting}

\gls{poetry} se vale de un fichero \gls{toml} que gestiona las \glspl{dependencia} del proyecto. Para iniciar el \gls{repositorio} se utiliza el comando
\begin{lstlisting}[style=consola]
	poetry init
\end{lstlisting}

En esta fase, se responderán una serie de cuestiones para generar la documentación relativa al proyecto (nombre, autor, versión, descripción, etc...). Y se podrán añadir las \glspl{dependencia} de manera interactiva, buscando los paquetes que utiliza el proyecto hasta el momento.

Para correr \glspl{script} de \gls{python}, debemos añadir las siguientes líneas al fichero \gls{toml}
\begin{lstlisting}[style=consola]
	[tool.poetry.script]
	script = 'python3 script.py'
\end{lstlisting}

Una vez guardada la configuración, se debe utilizar el siguiente comando para crear el entorno virtual con las \glspl{dependencia} especificadas y ejecutará el \gls{script} de \gls{python}. 
\begin{lstlisting}[style=consola]
	poetry run script
\end{lstlisting}

\section{Gestor de tareas}
En el ámbito del desarrollo de software y la gestión de proyectos cada vez es más complicado llevar a cabo una coordinación entre todos los entornos de desarrollo. Por ello, contar con un \gls{tareas} es indispensable. Este tipo de herramientas también se conocen como \gls{buildtools}. 

Para escoger un gestor de dependencias para \Gls{python} se valora mucho la experiencia previa, ya que aliviará la carga de aprender el uso de la herramienta de cara al desarrollo del proyecto. Por otro lado, se considera que exista una buena documentación para afrontar los desafíos que puedan surgir a lo largo del proyecto. 

Se han considerado dos herramientas principalmente: 
\begin{enumerate}
	\item Poetry scripts
	\item Invoke
\end{enumerate}

Se considera usar \gls{poetry} ya que se utiliza como gestor de dependencias y permite la ejecución de comandos añadiendo una etiqueta al ``pyproject.toml'' para especificar el nombre del script y la ruta del fichero que contiene las instrucciones de la tarea a automatizar. La configuración es sencilla y no requiere instalar ninguna dependencia extra.

Por otra parte, \href{https://www.pyinvoke.org/}{Invoke}, es una herramienta que también coge su inspiración de Make o Rake. Crea una \gls{API} de alto nivel para ejecutar comandos organizados en funciones dentro del fichero ``task.py''. Fue separado de Fabric, ya que muchos usuarios solo necesitaban o bien lanzar comandos a través de ssh o bien solo usan comandos en local. 

Se ha escogido \Gls{invoke} debido a que se ha utilizado en otros proyectos personales desarrollados en \Gls{python} con éxito.

Para añadir Invoke al proyecto se ha de instalar por medio de Pip y posteriormente añadirla a las \glspl{dependencia} del proyecto.
\begin{lstlisting}[style=consola]
	pip install invoke
	poetry add invoke
\end{lstlisting}

Y solo quedaría generar el \gls{script} de python con las tareas a automatizar. Dicho fichero se llamará ``task.py'' y contiene las siguientes instrucciones. 

\begin{lstlisting}[style=consola]
	cd doc
	pdflatex -interaction=nonstopmode proyecto.tex
	biber proyecto
	pdflatex -interaction=nonstopmode proyecto.tex
	pdflatex -interaction=nonstopmode proyecto.tex
\end{lstlisting}
La primera instrucción genera en formato pdf la documentación del proyecto, sin preguntar en los posibles errores que pueda encontrar el compilador. En caso de darse fallo, no generaría el fichero pdf. Cabe destacar que se realiza en una sola \gls{shell}, pero para darle mayor legibilidad se han separado los pasos. En la generación del fichero se crean multitud de archivos intermedios que se utilizan tanto para la generación de la bibliografía del proyecto, como para generar el pdf final. 

La segunda tarea se encarga de eliminar los ficheros intermedios generados por el compilador.
\begin{lstlisting}[style=consola]
	rm -f doc/*.aux doc/*.bbl doc/*.bcf doc/*.blg doc/*.log doc/*.out doc/*.run.xml doc/*.toc
\end{lstlisting}

La tercera tarea, instala las \glspl{dependencia} necesarias en el proyecto, por ahora, solo existe una \gls{dependencia} a utilizar que se trata de la propia librería de Invoke para el fichero ``task.py''. En esta tarea se diferencian dos ejecuciones, es posible instalar las \glspl{dependencia} de desarrollador o producción. Todo depende del \gls{flag} --dev, si se utiliza en la ejecución se instalarán las \glspl{dependencia} de desarrollador y si no las de producción. 
\begin{lstlisting}[style=consola]
	if(dev):
		print("Instalando dependencias de dev...")
		
		run("poetry install", shell="/bin/sh")
	else:
		print("Instalando dependencias...")
		run("poetry install --no-dev", shell="/bin/sh")
\end{lstlisting}
\newpage
El uso del \gls{tareas} es muy sencillo, solo se tiene que llamar a la utilidad Invoke y especificar la tarea a realizar de la siguiente manera
\begin{lstlisting}[style=consola]
	invoke pdf
	invoke clean
	invoke install
	invoke install --dev
\end{lstlisting}